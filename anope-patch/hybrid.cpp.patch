--- a/modules/protocol/hybrid.cpp
+++ b/modules/protocol/hybrid.cpp
@@ -15,6 +15,7 @@

 #include "module.h"
 #include "modules/chanserv/mode.h"
+#include "modules/nickserv/sasl.h"

 static Anope::string UplinkSID;

@@ -20,10 +21,11 @@

 class HybridProto final
 	: public IRCDProto
+	, SASL::ProtocolInterface
 {
 	void SendSVSKill(const MessageSource &source, User *u, const Anope::string &buf) override
 	{
@@ -30,7 +32,7 @@

 public:
-	HybridProto(Module *creator) : IRCDProto(creator, "ircd-hybrid 8.2.34+")
+	HybridProto(Module *creator) : IRCDProto(creator, "ircd-hybrid 8.2.34+"), SASL::ProtocolInterface(creator)
 	{
 		DefaultPseudoclientModes = "+oi";
 		CanSVSNick = true;
@@ -273,6 +275,44 @@

 		return true;
 	}
+
+	void SendSASLMessage(const SASL::Message &message) override
+	{
+		Server *s = Server::Find(message.target.substr(0, 3));
+		auto target = s ? s->GetName() : message.target.substr(0, 3);
+
+		auto newparams = message.data;
+		newparams.insert(newparams.begin(), { target, "SASL", message.source, message.target, message.type });
+		Uplink::SendInternal({}, Me, "ENCAP", newparams);
+	}
+
+	void SendSVSLogin(const Anope::string &uid, NickAlias *na) override
+	{
+		Server *s = Server::Find(uid.substr(0, 3));
+		Anope::string target = s ? s->GetName() : uid.substr(0, 3);
+
+		if (na)
+		{
+			Uplink::Send("ENCAP", target, "SVSLOGIN", uid, '*', '*',
+				na->GetVHostHost().empty() ? "*" : na->GetVHostHost(),
+				na->nc->display);
+		}
+		else
+		{
+			Uplink::Send("SVSACCOUNT", uid, 0, '*');
+		}
+	}
+
+	void SendSASLMechanisms(std::vector<Anope::string> &mechs) override
+	{
+		Anope::string mechlist;
+		for (unsigned i = 0; i < mechs.size(); ++i)
+			mechlist += (i > 0 ? "," : "") + mechs[i];
+		Uplink::Send("ENCAP", '*', "MECHLIST", mechlist);
+	}
 };

 struct IRCDMessageBMask final
@@ -630,6 +670,33 @@
 	}
 };

+struct IRCDMessageEncap final
+	: IRCDMessage
+{
+	IRCDMessageEncap(Module *creator) : IRCDMessage(creator, "ENCAP", 3) { SetFlag(FLAG_REQUIRE_SERVER); SetFlag(FLAG_SOFT_LIMIT); }
+
+	void Run(MessageSource &source, const std::vector<Anope::string> &params, const Anope::map<Anope::string> &tags) override
+	{
+		/*
+		 * Received: :0MC ENCAP * SASL 0MCAAAAAB * S PLAIN
+		 * params[0] = *
+		 * params[1] = SASL
+		 * params[2] = source uid
+		 * params[3] = target uid
+		 * params[4] = type (S/C/D/H)
+		 * params[5+] = data
+		 */
+		if (params[1] == "SASL" && SASL::service && params.size() >= 6)
+		{
+			SASL::Message m;
+			m.source = params[2];
+			m.target = params[3];
+			m.type = params[4];
+			m.data.assign(params.begin() + 5, params.end());
+			SASL::service->ProcessMessage(m);
+		}
+	}
+};
+
 struct IRCDMessageUID final
 	: IRCDMessage
 {
@@ -653,6 +720,7 @@

 	/* Our message handlers */
 	IRCDMessageBMask message_bmask;
+	IRCDMessageEncap message_encap;
 	IRCDMessageCapab message_capab;
 	IRCDMessageCertFP message_certfp;
 	IRCDMessageEOB message_eob;
@@ -689,6 +757,7 @@
 		message_whois(this),
 		message_bmask(this),
+		message_encap(this),
 		message_capab(this),
 		message_certfp(this),
 		message_eob(this),
